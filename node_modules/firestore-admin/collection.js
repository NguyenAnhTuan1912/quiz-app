let DOCUMENT = require('./document.js');

//-----------------------------------
// COLLECTION

class Collection {
  /**
   * @param {object} collection A reference to the CollectionReference.
   */
  constructor(collection) {
    this.collection_ = collection;
  }

  /**
   * The Firestore instance for the Firestore database (useful for performing transactions, etc).
   * @returns {object} Returns an object.
   */
  Firestore() {
    return this.collection_.firestore;
  }

  /**
   * Get this collection's ID.
   * @returns {string} Returns a string.
   */
  Id() {
    return this.collection_.id;
  }

  /**
   * A reference to the containing document if this is a subcollection. Else, it is null.
   * @returns {object} Returns an object.
   */
  Parent() {
    return this.collection_.parent;
  }

  /**
   * A string representing the path of the referenced collection (relative to the root of the database).
   * @returns {string} Returns a string.
   */
  Path() {
    return this.collection_.path;
  }

  /**
   * @returns {object} Returns a CollectionReference to this collection.
   */
  Ref() {
    return this.collection_;
  }

  /**
   * Add a new document to this collection with the specified data, assigning it a document ID automatically.
   * @param {string} data Object containing data.
   * @returns {Promise<object>} Returns a Promise that resolves if successful and returns a DocumentReference pointing to the newly created document.
   */
  Add(data) {
    return new Promise((resolve, reject) => {
      this.collection_.add(data).then(documentReference => {
        resolve(documentReference);
      }).catch(error => reject(`Failed to add a new document: ${error}.`));
    });
  }

  /**
   * Gets a DocumentReference instance that refers to the document at the specified path. If no path is specified, an automatically-generated unique ID will be used for the returned DocumentReference.
   * @param {string} documentPath (Optional) A slash-separated path to a document.
   * @returns {object} Returns a DocumentReference.
   */
  Doc(documentPath) {
    return documentPath ? this.collection_.doc(documentPath) : this.collection_.doc();
  }

  /**
   * Creates and returns a new Query that ends at the provided set of field values relative to the order of the query. The order of the provided values must match the order of the order by clauses of the query.
   * @param {string} fieldValues The set of field values to end the query at. Value may be repeated.
   * @returns {Promise<object>} Returns a Promise that resolves if successful and returns a query with the new ending point.
   */
  EndAt(fieldValues) {
    return this.collection_.endAt(fieldValues); // FIX ???
  }

  /**
   * Creates and returns a new Query that ends before the set of field values relative to the order of the query. The order of the provided values must match the order of the order by clauses of the query.
   * @param {string} fieldValues The set of field values to end the query at. Value may be repeated.
   * @returns {Promise<object>} Returns a Promise that resolves if successful and returns a query with the new ending point.
   */
  EndBefore(fieldValues) {
    return this.collection_.endBefore(fieldValues); // FIX ???
  }

  /**
   * Get this collection's snapsot.
   * @returns {Promise<object>} Returns a Promise that resolves if successful and returns a QuerySnapshot.
   */
  GetSnapshot() {
    return new Promise((resolve, reject) => {
      this.collection_.get().then(snapshot => {
        resolve(snapshot);
      }).catch(error => reject(`Failed to get collection snapshot: ${error}.`));
    });
  }

  /**
   * Creates and returns a new Query that's additionally limited to only return up to the specified number of documents.  
   * @param {number} n The maximum number of items to return.
   * @returns {object} Returns a new (immutable) instance of the Query (rather than modify the existing instance) to impose the limit.
   */
  Limit(n) {
    return this.collection_.limit(n);
  }

  /**
   * Creates and returns a new Query that's additionally limited to only return up to the specified number of documents.  
   * @param {number} n The offset to apply to the Query results.
   * @returns {object} Returns a new (immutable) instance of the Query (rather than modify the existing instance) to impose the offset.
   */
  Offset(n) {
    return this.collection_.offset(n);
  }

  /**
   * Attaches a listener for QuerySnapshot events.
   * @param {object} querySnapshotCallback A callback to be called every time a new QuerySnapshot is available.
   * @param {object} errorCallback (Optional) A callback to be called if the listen fails or is cancelled. No further callbacks will occur.
   * @returns {function} Returns an unsubscribe function that can be called to cancel the snapshot listener.
   */
  OnSnapshot(
    querySnapshotCallback, errorCallback) {
    if (!errorCallback)
      return this.collection_.onSnapshot(querySnapshotCallback);

    return this.collection_.onSnapshot(documentSnapshotCallback, errorCallback);
  }

  /**
   * Creates and returns a new Query that's additionally sorted by the specified field, optionally in descending order instead of ascending. 
   * @param {string} fieldPath The field to sort by.
   * @param {string} directionString (Optional) Direction to sort by ('asc' or 'desc'). If not specified, order will be ascending.
   * @returns {object} Returns a new (immutable) instance of the Query (rather than modify the existing instance) to impose the field mask.
   */
  OrderBy(fieldPath, directionStr) {
    if (!directionStr)
      return this.collection_.orderBy(fieldPath, directionStr);

    return this.collection_.orderBy(fieldPath);
  }


  /**
   * Creates and returns a new Query instance. 
   * You can specify a list of field paths to return, or use an empty list to only return the references of matching documents. 
   * @param {string} fieldPaths The field paths to return. Value may be repeated.
   * @returns {object} Returns a new (immutable) instance of the Query (rather than modify the existing instance) to impose the field mask.
   */
  Select(fieldPaths) {
    return this.collection_.select(fieldPaths); // FIX ??? Pass in array to function...
  }

  /**
   * Creates and returns a new Query that starts after the provided set of field values relative to the order of the query. 
   * The order of the provided values must match the order of the order by clauses of the query.
   * @param {string} fieldValues The set of field values to start the query after. Value may be repeated.
   * @returns {object} Returns a new Query that starts after the provided set of field values relative to the order of the query.
   */
  StartAfter(fieldValues) {
    return this.collection_.startAfter(fieldValues); // FIX ??? Pass in array to function...
  }

  /**
   * Creates and returns a new Query instance. 
   * The order of the provided values must match the order of the order by clauses of the query.
   * @param {string} fieldValues The set of field values to start the query at. Value may be repeated.
   * @returns {object} Returns a new Query that starts at the provided set of field values relative to the order of the query.
   */
  StartAt(fieldValues) {
    return this.collection_.startAfter(fieldValues); // FIX ??? Pass in array to function...
  }

  /**
   * Executes the query and streams the results as DocumentSnapshots.
   * @returns {object} Returns a Stream containing DocumentSnapshot.
   */
  Stream() {
    return this.collection_.stream();
  }

  /**
   * Executes the query and streams the results as DocumentSnapshots.
   * @param {function} dataCallback Callback function for when data stream starts. Must take document snapshot as argument.
   * @param {function} endCallback Callback function for when data tream ends.
   * @returns {object} Returns a Stream containing DocumentSnapshot.
   */
  StreamActions(dataCallback, endCallback) {
    this.query_.on('data', dataCallback).on('end', endCallback);
  }

  /**
   * Creates and a new Query with the additional filter that documents must contain the specified field and the value should satisfy the relation constraint provided. 
   * @param {string|FieldPath} fieldPath The name of a property value to compare.
   * @param {string} opStr A comparison operation in the form of a string (e.g., "<").
   * @param {any} value The value to which to compare the field for inclusion in a query.
   * @returns {object} Returns a new (immutable) instance of the Query (rather than modify the existing instance) to impose the filter.
   */
  Where(fieldPath, opStr, value) {
    return this.collection_.where(fieldPath, opStr, value);
  }

  /**
   * Create a document. If document exists, it will overwrite current data. Otherwise it will simply be added.
   * @param {string} name 
   * @param {object} data 
   * @returns {Promise<string>} Returns a Promise that resolves with the update time.
   */
  SetDoc(name, data) {
    return new Promise((resolve, reject) => {
      this.collection_.doc(name).set(data).then(res => {
        resolve(res.updateTime);
      }).catch(error => reject(`Failed to add document: ${error}.`));
    });
  }

  /**
   * Update document fields. If a field doesn't exist, it will be added. If the document doesn't exist, the update fails. (Does not overwrite entire document)
   * @param {string} name 
   * @param {object} data 
   * @returns {Promise<string>} Returns a promise that resolves with the update time.
   */
  UpdateDoc(name, data) {
    return new Promise((resolve, reject) => {
      this.collection_.doc(name).update(data).then(res => {
        resolve(res.updateTime);
      }).catch(error => reject(`Failed to update document: ${error}.`));
    });
  }

  /**
   * Delete document. A delete for a non-existing document is treated as a success. Does not delete subcollections, just the reference to the document.
   * @param {string} name 
   * @returns {Promise<string>} Returns a Promise that resolves with the write time.
   */
  DeleteDoc(name) {
    return new Promise((resolve, reject) => {
      this.collection_.doc(name).delete().then(res => {
        resolve(res.writeTime);
      }).catch(error => reject(`Failed to delete document: ${error}.`));
    });
  }

  /**
   * Get all document snapshots in this collection.
   * @returns {Promise<Array>} Returns a Promise that resolves with a list of DocumentSnapshot objects.
   */
  GetDocSnapshots() {
    return new Promise((resolve, reject) => {
      this.collection_.get().then(snapshot => {
        if (snapshot.empty) {
          resolve(null);
          return;
        }

        let docSnapshots = snapshot.docs;
        resolve(docSnapshots);
      }).catch(error => reject(`Failed to get doc snapshots: ${error}.`));
    });
  }

  /**
   * Get document snapshot by name.
   * @param {string} name
   * @returns {Promise<object>} Returns a Promise that resolves with a DocumentSnapshot object.
   */
  GetDocSnapshot(name) {
    return new Promise((resolve, reject) => {
      this.GetDocSnapshots().then(docSnapshots => {
        if (!docSnapshots || docSnapshots.length == 0) {
          resolve(null);
          return;
        }

        let filteredDocs = docSnapshots.filter(x => x.id == name);
        if (!filteredDocs || filteredDocs.length == 0) {
          resolve(null);
          return;
        }

        resolve(filteredDocs[0]);
      }).catch(error => reject(`Failed to get doc snapshot by name: ${error}.`));
    });
  }

  /**
   * Allows you to insert data while at the same time preventing write conflicts. The generated timestamp is the doc name for this entry.
   * @param {object} data An object containing property names and their associated values.
   * @returns {Promise<{key: string, updateTime: string}>} Returns a Promise that resolves with an object containing a 'key' (document name) and update time.
   */
  Push(data) {
    return new Promise((resolve, reject) => {
      let newDocRef = this.collection_.push();

      newDocRef.set(data).then(res => {
        ret = { key: newDocRef.key, updateTime: res.updateTime };
        resolve(ret);
      }).catch(error => reject(`Failed to push data: ${error}.`));
    });
  }
}

//-----------------------------
// EXPORTS

exports.Collection = Collection;