let FIREBASE_ADMIN = require('firebase-admin');

//-----------------------------------
// DELETE

class Delete {
  /**
   * @param {object} firestoreDb A reference to the database.
   */
  constructor(firestoreDb) {
    this.firestoreDb_ = firestoreDb;
  }

  /**
   * Delete entire collections using a batch delete mthod.
   * @param {object} query Reference to the query made on the collection. 
   * @param {number} batchSize Integer value representing the size of the deletion batch.
   * @returns {Promise} Returns a Promise that resolves if successful.
   */
  DeleteQueryBatch_(query, batchSize) {
    return new Promise((resolve, reject) => {
      query.get().then((snapshot) => {

        // When there are no documents left, we are done
        if (snapshot.size == 0)
          return 0;

        // Delete documents in a batch
        let batch = this.firestoreDb_.batch();
        snapshot.docs.forEach((doc) => batch.delete(doc.ref));

        batch.commit().then(() => {
          let numDeleted = snapshot.size;

          if (numDeleted === 0) {
            resolve();
            return;
          }

          // Recurse on the next process tick, to avoid
          // exploding the stack.
          process.nextTick(() => {
            this.DeleteQueryBatch_(query, batchSize);
          });
        });
      }).catch(error => reject(error));
    });
  }

  /**
   * Delete and entire collection and its descendants (children). Uses batched deletes.
   * @param {object} collection Reference to the collection. 
   * @param {number} batchSize Integer value representing the size of the deletion batch.
   * @returns {Promise} Returns a Promise that resolves if successful.
   */
  DeleteCollection_(collection, batchSize) {
    return new Promise((resolve, reject) => {
      let query = collection.orderBy('__name__').limit(batchSize);

      this.DeleteQueryBatch_(query, batchSize).then(success => {
        resolve();
      }).catch(error => reject(`Failed to delete collection: ${error}.`));
    });
  }

  /**
   * Delete a collection. Uses batched deletes.
   * @param {object} collection Reference to the collection.
   * @param {number} batchSize Integer value representing the size of the deletion batch.
   * @returns {Promise} Returns a Promise that resolves if successful.
   */
  Collection(collection, batchSize) {
    return new Promise((resolve, reject) => {
      this.DeleteCollection_(collection, batchSize).then(success => {
        resolve();
      }).catch(error => reject(error));
    });
  }

  /**
   * Delete a document. Uses batched deletes when deleting collections. A delete for a non-existing document is treated as a success.
   * @param {object} doc Reference to the document.
   * @param {number} batchSize Integer value representing the size of the deletion batch.
   * @returns {Promise<string>} Returns a Promise that resolves with the update time.
   */
  Document(doc, batchSize) {
    return new Promise((resolve, reject) => {
      // Check for collections
      doc.getCollections().then(collections => {
        if (!collections || collections.length == 0) {
          doc.delete().then(res => {
            resolve(res.writeTime);
          }).catch(error => reject`Failed to delete document: ${error}.`);
        }
        else {
          let actions = collections.map(x => this.Collection(x, batchSize));
          Promise.all(actions).then(results => {
            doc.delete().then(res => {
              resolve(res.writeTime);
            }).catch(error => reject(`Failed to delete document: ${error}.`));
          }).catch(error => reject(`Failed to delete document: ${error}.`));
        }
      }).catch(error => reject(`Failed to get collections: ${error}.`));
    });
  }

  /**
   * 
   * @param {object} doc Reference to the document.
   * @param {Array<string>} names List of field names.
   * @returns {Promise<string>} Returns a Promise that resolves with the update time.
   */
  Fields(doc, names) {
    return new Promise((resolve, reject) => {
      let FieldValue = FIREBASE_ADMIN.firestore.FieldValue;

      let data = {};
      names.forEach(name => data[name] = FieldValue.delete());

      doc.update(data).then(res => {
        resolve(res.updateTime);
      }).catch(error => reject(`Failed to delete fields: ${error}.`));
    });
  }
}

//-------------------------------
// EXPORTS

exports.Delete = Delete;