//-----------------------------------
// WRITE BATCH

class WriteBatch {
  constructor(firestoreDb) {
    /**
     * @param {object} firestoreDb A reference to the database.
     */
    this.firestoreDb_ = firestoreDb;
    this.batch_ = firestoreDb.batch();
  }

  /**
   * @returns {object} Returns a reference to the WriteBatch instance. (Used for chaining calls)
   */
  Ref() {
    return this.batch_;
  }

  /**
   * Atomically commits all pending operations to the database and verifies all preconditions. 
   * Fails the entire write if any precondition is not met.
   * @returns {Promise<object>} Returns a Promise that resolves when the batch is complete and returns a list of WriteResult objects (contain "writeTime" prperty).
   */
  Commit() {
    return new Promise((resolve, reject) => {
      this.batch_.commit().then(writeResults => {
        this.batch_ = this.firestoreDb_.batch(); // Get a new write batch
        resolve(writeResults);
      }).catch(error => reject(`Failed to commit batch: ${error}.`));
    });
  }

  /**
   * Create a document with the provided object values. 
   * This will fail the batch if a document exists at its location.
   * @param {object} collectionName Reference to the collection.
   * @param {object} docName Name of document.
   * @param {object} data Object containing property names and their associated values.
   */
  Create(collectionName, docName, data) {
    let docRef = this.firestoreDb_.collection(collectionName).doc(docName);
    this.batch_.create(docRef, data);
  }

  /**
   * Delete a document from the database. 
   * Does not delete subcollections, just the reference to the document.
   * @param {object} collectionName Reference to the collection.
   * @param {object} docName Name of document.
   */
  Delete(collectionName, docName) {
    let docRef = this.firestoreDb_.collection(collectionName).doc(docName);
    this.batch_.delete(docRef);
  }

  /**
   * Write to the document. (Will overwrite entire document!)
   * If the document does not exist yet, it will be created. 
   * @param {object} collectionName Reference to the collection.
   * @param {object} docName Name of document.
   * @param {object} data Object containing property names and their associated values.
   */
  Set(collectionName, docName, data) {
    let docRef = this.firestoreDb_.collection(collectionName).doc(docName);
    this.batch_.set(docRef, data);
  }

  /**
   * Update fields of the document. 
   * If the document doesn't yet exist, the update fails and the entire batch will be rejected.
   * The update() method accepts either an object with field paths encoded as keys and field values encoded as values, or a variable number of arguments that alternate between field paths and field values. 
   * Nested fields can be updated by providing dot-separated field path strings or by providing FieldPath objects.
   * @param {object} collectionName Reference to the collection.
   * @param {object} docName Name of document.
   * @param {object} data Object containing property names and their associated values.
   */
  Update(collectionName, docName, data) {
    let docRef = this.firestoreDb_.collection(collectionName).doc(docName);
    this.batch_.update(docRef, data);
  }
}

//---------------------------
// EXPORTS

exports.WriteBatch = WriteBatch;