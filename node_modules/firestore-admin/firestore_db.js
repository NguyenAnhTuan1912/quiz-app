let FIREBASE_ADMIN = require('firebase-admin');
let DELETE = require('./delete.js').Delete;

//-------------------------------
// CONNECT to Firebase DB

class FirestoreDb {
  /**
   * Create a connection to the firebase databse.
   * @param {string} serviceAccountKeyFilepath The path to the service account key file. (PRIVATE KEY)
   */
  constructor(serviceAccountKeyFilepath) {

    // Acquire service account config
    let serviceAccount = require(serviceAccountKeyFilepath);

    // Verify credentials
    FIREBASE_ADMIN.initializeApp({
      credential: FIREBASE_ADMIN.credential.cert(serviceAccount),
    });

    // Store reference for admin API
    this.admin_ = FIREBASE_ADMIN;

    // Acquire database connection
    this.db_ = FIREBASE_ADMIN.firestore();

    // Initialize other functionality
    this.delete_ = new DELETE(this.db_);
  }

  /**
   * Get a reference to the database
   * @returns {object} Returns a firebase database reference.
   */
  Ref() {
    return this.db_;
  }

  /**
   * Get a reference to the admin API.
   * @returns {object} Returns a firebase admin API reference.
   */
  Admin() {
    return this.admin_;
  }

  /**
   * Write or replace data in a collection. (Will overwrite data if it already exists).
   * @param {string} collectionName
   * @param {string} docName Alias to identify the data.
   * @param {object} data An object containing property names and their associated values.
   * @return {Promise<string>} Returns a Promise that resolves with the the update time.
   */
  SetData(collectionName, docName, data) {
    return new Promise((resolve, reject) => {
      this.db_.collection(collectionName).doc(docName).set(data).then(res => {
        resolve(res.updateTime);
      }).catch(error => reject(`Failed to set data: ${error}.`));
    });
  }

  /**
   * Update properties of the specified doc. If a property doesn't exist, it will be added. If a property exists, it will be overwritten.
   * @param {string} collectionName
   * @param {string} docName Alias to identify the data.
   * @param {object} data An object containing property names and their associated values.
   * @returns {Promise<string>} Returns a Promise that resolves with the update time.
   */
  UpdateData(collectionName, docName, data) {
    return new Promise((resolve, reject) => {
      this.db_.collection(collectionName).doc(docName).update(data).then(res => {
        resolve(res.updateTime);
      }).catch(error => reject(`Failed to update data: ${error}.`));
    });
  }

  /**
   * Delete a document and its children from the specified collection.
   * @param {string} collectionName
   * @param {string} docName Alias to identify the data.
   * @param {number} batchSize (Optional) Integer value representing the size of the deletion batch. Default batch size is 10.
   * @returns {Promise<string>} Returns a Promise that resolves with the update time.
   */
  DeleteDoc(collectionName, docName, batchSize) {
    return new Promise((resolve, reject) => {
      let doc = this.db_.collection(collectionName).doc(docName);
      let adjustedBatchSize = batchSize ? batchSize : 10;

      this.delete_.Document(doc, adjustedBatchSize).then(updateTime => {
        resolve(updateTime);
      }).catch(error => reject(`Failed to delete document: ${error}.`));
    });
  }

  /**
   * Retrieve all document snapshots in a collection.
   * @param {string} collectionName
   * @returns {Promise<Array>} Returns a Promise that resolves with a list of DocumentSnapshot objects.
   */
  GetDocSnapshots(collectionName) {
    return new Promise((resolve, reject) => {
      this.db_.collection(collectionName).get().then(snapshot => {
        if (snapshot.empty) {
          resolve(null);
          return;
        }

        let docSnapshots = snapshot.docs;

        resolve(docSnapshots);
      }).catch(error => reject(`Failed to get document snapshots: ${error}.`));
    });
  }

  /**
   * Retrieve a single DocumentSnapshot from the specified collection.
   * @param {string} collectionName 
   * @param {string} docName Alias to identify the data.
   * @returns {Promise<object>} Returns a Promise that resolves with a single Document.
   */
  GetDocSnapshot(collectionName, docName) {
    return new Promise((resolve, reject) => {

      this.db_.collection(collectionName).get().then(snapshot => {
        if (snapshot.empty) {
          resolve(null);
          return;
        }

        let docSnapshots = snapshot.docs;

        let filteredDocs = docSnapshots.filter(x => x.id == docName);
        if (!filteredDocs || filteredDocs.length == 0) {
          resolve(null);
          return;
        }

        resolve(filteredDocs[0]);
      }).catch(error => reject(`Failed to get document snapshot: ${error}.`));
    });
  }

  /**
   * Delete a field from the specified document.
   * @param {string} collectionName Similar to a table name in SQL.
   * @param {string} docName Alias to identify the data.
   * @param {object} fieldNames A list of field names.
   * @returns {Promise} Returns a Promise that resolves with the update time.
   */
  DeleteFields(collectionName, docName, fieldNames) {
    return new Promise((resolve, reject) => {
      let doc = this.db_.collection(collectionName).doc(docName);

      this.delete_.Fields(doc, fieldNames).then(updateTime => {
        resolve(updateTime);
      }).catch(error => reject(`Failed to delete fields: ${error}.`));
    });
  }

  /**
   * Allows you to insert data while at the same time preventing write conflicts. The generated timestamp is the doc name for this entry.
   * @param {string} collectionName 
   * @param {object} data An object containing property names and their associated values.
   * @returns {Promise<{key: string, updateTime: string}>} Returns a Promise that resolves and returns an object containing a 'key' (document name) and update time.
   */
  Push(collectionName, data) {
    return new Promise((resolve, reject) => {
      let newDocRef = this.db_.collection(collectionName).push();

      newDocRef.set(data).then(res => {
        ret = { key: newDocRef.key, updateTime: res.updateTime };
        resolve(ret);
      }).catch(error => reject(`Failed to push data: ${error}.`));
    });
  }
}

//------------------------------
// EXPORTS

exports.FirestoreDb = FirestoreDb;