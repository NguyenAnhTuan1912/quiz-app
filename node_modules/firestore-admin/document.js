let FIREBASE_ADMIN = require('firebase-admin');

//-----------------------------------
// DOCUMENT

class Document {
  /**
   * @param {object} doc A reference to the DocumentReference.
   */
  constructor(doc) {
    this.doc_ = doc;
  }

  /**
   * The Firestore instance for the Firestore database (useful for performing transactions, etc).
   * @returns {object} Returns an object.
   */
  Firestore() {
    return this.doc_.firestore;
  }

  /**
   * The last path document of the referenced document. (Name of document is stored here)
   * @returns {string} Returns a string.
   */
  Id() {
    return this.doc_.id;
  }

  /**
   * A reference to the collection to which this DocumentReference belongs.
   * @returns {object} Returns an object.
   */
  Parent() {
    return this.doc_.parent;
  }

  /**
   * A string representing the path of the referenced document (relative to the root of the database).
   * @returns {string} Returns a string.
   */
  Path() {
    return this.doc_.path;
  }

  /**
   * @returns {object} Returns a DocumentReference to this document.
   */
  Ref() {
    return this.doc_;
  }

  /**
   * Add a collection.
   * @param {string} collectionName
   * @param {string} docName
   * @param {string} data Object containing data.
   * @returns {Promise<string>} Returns a promise that resolves with the update time.
   */
  AddCollection(collectionName, docName, data) {
    return new Promise((resolve, reject) => {
      this.doc_.collection(collectionName).doc(docName).set(data).then(res => {
        resolve(res.updateTime);
      }).catch(error => reject(`Failed to add collection: ${error}.`));
    });
  }

  /**
   * Gets a CollectionReference instance that refers to the collection at the specified path.
   * @param {string} collectionPath A slash-separated path to a collection.
   * @returns {object} Returns an object.
   */
  Collection(collectionPath) {
    return this.doc_.collection(collectionPath);
  }

  /**
   * Create a document with the provided object values. This will fail the write if a document exists at its location.
   * @param {object} data 
   * @returns {Promise<string>} Returns a Promise that resolves with the update time.
   */
  Create(data) {
    return new Promise((resolve, reject) => {
      this.doc_.create(data).then((res) => {
        resolve(res.updateTime);
      }).catch(error => reject(`Failed to create document: ${error}.`));
    });
  }

  /**
   * Delete this document. A delete for a non-existing document is treated as a success. Does not delete subcollections, just the reference to the document.
   * @returns {Promise<string>} Returns a Promise that resolves with the write time.
   */
  Delete() {
    return new Promise((resolve, reject) => {
      this.doc_.delete().then(res => {
        resolve(res.writeTime);
      }).catch(error => reject(`Failed to delete document: ${error}.`));
    });
  }

  /**
   * Delete multiple fields.
   * @param {Array<string>} names List of field names.
   * @returns {Promise<string>} Returns a promise that resolves with the update time.
   */
  DeleteFields(names) {
    return new Promise((resolve, reject) => {
      let FieldValue = FIREBASE_ADMIN.firestore.FieldValue;

      let data = {};
      names.forEach(name => data[name] = FieldValue.delete());

      this.doc_.update(data).then(res => {
        resolve(res.updateTime);
      }).catch(error => reject(`Failed to delete fields: ${error}.`));
    });
  }

  /**
   * Delete a single field.
   * @param {string} name Field name
   * @returns {Promise<string>} Returns a promise that resolves with the update time.
   */
  DeleteField(name) {
    return new Promise((resolve, reject) => {
      let FieldValue = FIREBASE_ADMIN.firestore.FieldValue;

      let data = {};
      data[name] = FieldValue.delete();

      this.doc_.update(data).then(res => {
        resolve(res.updateTime);
      }).catch(error => reject(`Failed to delete field: ${error}.`));
    });
  }

  /**
   * Get all collections.
   * @returns {Promise<Array>} Returns a Promise that resolves with a list of CollectionReference objects.
   */
  GetCollections() {
    return new Promise((resolve, reject) => {
      this.doc_.getCollections().then(collections => {
        resolve(collections);
      }).catch(error => reject(`Failed to get collections: ${error}.`));
    });
  }

  /**
   * Get a collection by name.
   * @param {string} collectionName
   * @returns {Promise<object>} Returns a Promise that resolves with the desired CollectionReference (or null iof it doesn't exist).
   */
  GetCollection(collectionName) {
    return new Promise((resolve, reject) => {
      this.GetCollections().then(collections => {
        if (!collections || collections.length == 0) {
          resolve(null);
          return;
        }

        let filteredCollections = collections.filter(x => x.id == collectionName);
        if (!filteredCollections || filteredCollections.length == 0) {
          resolve(null);
          return;
        }

        resolve(filteredCollections[0]);
      }).catch(error => reject(`Failed to get collection: ${error}.`));
    });
  }

  /**
   * Get this document's snapshot. Contains information such as create time, id, if it exists, ref, etc.
   * @returns {Promise<object>} Returns a Promise that resolves with a DocumentSnapshot object.
   */
  GetSnapshot() {
    return new Promise((resolve, reject) => {
      this.doc_.get().then((snapshot) => {
        resolve(snapshot);
      }).catch(error => reject(`Failed to get document snapshot: ${error}.`));
    });
  }

  /**
   * Attaches a listener for DocumentSnapshot events.
   * @param {object} documentSnapshotCallback A callback to be called every time a new DocumentSnapshot is available.
   * @param {object} errorCallback (Optional) A callback to be called if the listen fails or is cancelled. No further callbacks will occur. If unset, errors will be logged to the console.
   * @returns {function} Returns an unsubscribe function that can be called to cancel the snapshot listener.
   */
  OnSnapshot(documentSnapshotCallback, errorCallback) {
    if (!errorCallback)
      return this.doc_.onSnapshot(documentSnapshotCallback);

    return this.doc_.onSnapshot(documentSnapshotCallback, errorCallback);
  }

  /**
   * Set data. (Will overwrite the entire doc)
   * @param {object} data Object containing data.
   * @returns {Promise<string>} Returns a promise that resolves with the update time.
   */
  Set(data) {
    return new Promise((resolve, reject) => {
      this.doc_.set(data).then(res => {
        resolve(res.updateTime);
      }).catch(error => reject(`Failed to set data: ${error}.`));
    });
  }

  /**
   * Update fields in the document specified in data. If a field doesn't exist, it will be added. If the document doesn't exist, the update fails. (Does not overwrite entire document)
   * @param {object} data Object containing data.
   * @returns {Promise<string>} Returns a promise that resolves with the update time.
   */
  Update(data) {
    return new Promise((resolve, reject) => {
      this.doc_.update(data).then(res => {
        resolve(res.updateTime);
      }).catch(error => reject(`Failed to update data: ${error}.`));
    });
  }
}

//-----------------------------
// EXPORTS

exports.Document = Document;